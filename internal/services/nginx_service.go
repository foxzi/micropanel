package services

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"text/template"

	"micropanel/internal/config"
	"micropanel/internal/models"
	"micropanel/internal/repository"
)

type NginxService struct {
	config     *config.Config
	siteRepo   *repository.SiteRepository
	domainRepo *repository.DomainRepository
}

func NewNginxService(cfg *config.Config, siteRepo *repository.SiteRepository, domainRepo *repository.DomainRepository) *NginxService {
	return &NginxService{
		config:     cfg,
		siteRepo:   siteRepo,
		domainRepo: domainRepo,
	}
}

const nginxSiteTemplate = `# Site: {{.Site.Name}} (ID: {{.Site.ID}})
# Generated by MicroPanel - DO NOT EDIT MANUALLY

server {
    listen 80;
    listen [::]:80;

    server_name{{range .Domains}} {{.Hostname}}{{end}};

    root {{.PublicPath}};
    index index.html index.htm;

    # Logging
    access_log {{.LogPath}}/access.log;
    error_log {{.LogPath}}/error.log;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;

    # ACME challenge for Let's Encrypt
    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }

    location / {
        try_files $uri $uri/ =404;
    }

    # Deny access to hidden files
    location ~ /\. {
        deny all;
    }
}
{{if .HasSSL}}
server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;

    server_name{{range .Domains}} {{.Hostname}}{{end}};

    ssl_certificate /etc/letsencrypt/live/{{.PrimaryDomain}}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/{{.PrimaryDomain}}/privkey.pem;
    ssl_session_timeout 1d;
    ssl_session_cache shared:SSL:50m;
    ssl_session_tickets off;

    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;

    # HSTS
    add_header Strict-Transport-Security "max-age=63072000" always;

    root {{.PublicPath}};
    index index.html index.htm;

    access_log {{.LogPath}}/access.log;
    error_log {{.LogPath}}/error.log;

    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;

    location / {
        try_files $uri $uri/ =404;
    }

    location ~ /\. {
        deny all;
    }
}
{{end}}
`

type nginxTemplateData struct {
	Site          *models.Site
	Domains       []*models.Domain
	PublicPath    string
	LogPath       string
	HasSSL        bool
	PrimaryDomain string
}

func (s *NginxService) GenerateConfig(siteID int64) (string, error) {
	site, err := s.siteRepo.GetByID(siteID)
	if err != nil {
		return "", fmt.Errorf("get site: %w", err)
	}

	domains, err := s.domainRepo.ListBySite(siteID)
	if err != nil {
		return "", fmt.Errorf("get domains: %w", err)
	}

	if len(domains) == 0 {
		return "", fmt.Errorf("site has no domains")
	}

	// Find primary domain
	primaryDomain := domains[0].Hostname
	hasSSL := false
	for _, d := range domains {
		if d.IsPrimary {
			primaryDomain = d.Hostname
		}
		if d.SSLEnabled {
			hasSSL = true
		}
	}

	data := nginxTemplateData{
		Site:          site,
		Domains:       domains,
		PublicPath:    filepath.Join(s.config.Sites.Path, fmt.Sprintf("%d", siteID), "public"),
		LogPath:       filepath.Join(s.config.Sites.Path, fmt.Sprintf("%d", siteID), "logs"),
		HasSSL:        hasSSL,
		PrimaryDomain: primaryDomain,
	}

	tmpl, err := template.New("nginx").Parse(nginxSiteTemplate)
	if err != nil {
		return "", fmt.Errorf("parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("execute template: %w", err)
	}

	return buf.String(), nil
}

func (s *NginxService) WriteConfig(siteID int64) error {
	config, err := s.GenerateConfig(siteID)
	if err != nil {
		return err
	}

	configPath := s.getConfigPath(siteID)

	// Ensure directory exists
	if err := os.MkdirAll(filepath.Dir(configPath), 0755); err != nil {
		return fmt.Errorf("create config directory: %w", err)
	}

	// Write config file
	if err := os.WriteFile(configPath, []byte(config), 0644); err != nil {
		return fmt.Errorf("write config file: %w", err)
	}

	return nil
}

func (s *NginxService) RemoveConfig(siteID int64) error {
	configPath := s.getConfigPath(siteID)
	if err := os.Remove(configPath); err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("remove config file: %w", err)
	}
	return nil
}

func (s *NginxService) TestConfig() error {
	cmd := exec.Command("nginx", "-t")
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("nginx test failed: %s", string(output))
	}
	return nil
}

func (s *NginxService) Reload() error {
	// Test config first
	if err := s.TestConfig(); err != nil {
		return err
	}

	cmd := exec.Command("nginx", "-s", "reload")
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("nginx reload failed: %s", string(output))
	}
	return nil
}

func (s *NginxService) ApplyConfig(siteID int64) error {
	// Backup existing config
	configPath := s.getConfigPath(siteID)
	backupPath := configPath + ".backup"

	// Read existing config for backup
	existingConfig, _ := os.ReadFile(configPath)

	// Write new config
	if err := s.WriteConfig(siteID); err != nil {
		return err
	}

	// Test nginx config
	if err := s.TestConfig(); err != nil {
		// Rollback on failure
		if len(existingConfig) > 0 {
			os.WriteFile(configPath, existingConfig, 0644)
		} else {
			os.Remove(configPath)
		}
		return fmt.Errorf("config test failed, rolled back: %w", err)
	}

	// Remove backup if exists
	os.Remove(backupPath)

	// Reload nginx
	return s.Reload()
}

func (s *NginxService) getConfigPath(siteID int64) string {
	return filepath.Join(s.config.Nginx.ConfigPath, fmt.Sprintf("panel-%d.conf", siteID))
}
