package services

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"

	"micropanel/internal/config"
	"micropanel/internal/models"
	"micropanel/internal/repository"
)

type NginxService struct {
	config       *config.Config
	siteRepo     *repository.SiteRepository
	domainRepo   *repository.DomainRepository
	redirectRepo *repository.RedirectRepository
	authZoneRepo *repository.AuthZoneRepository
}

func NewNginxService(cfg *config.Config, siteRepo *repository.SiteRepository, domainRepo *repository.DomainRepository) *NginxService {
	return &NginxService{
		config:     cfg,
		siteRepo:   siteRepo,
		domainRepo: domainRepo,
	}
}

func (s *NginxService) SetRedirectRepo(repo *repository.RedirectRepository) {
	s.redirectRepo = repo
}

func (s *NginxService) SetAuthZoneRepo(repo *repository.AuthZoneRepository) {
	s.authZoneRepo = repo
}

const nginxSiteTemplate = `# Site: {{.Site.Name}} (ID: {{.Site.ID}})
# Generated by MicroPanel - DO NOT EDIT MANUALLY

server {
    listen 80;
    listen [::]:80;

    server_name {{.ServerNames}};

    root {{.PublicPath}};
    index index.html index.htm;

    # Logging
    access_log /var/log/nginx/{{.LogName}}_access.log;
    error_log /var/log/nginx/{{.LogName}}_error.log;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;

    # ACME challenge for Let's Encrypt
    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }
{{range .Redirects}}{{if .IsEnabled}}
    # Redirect: {{.SourcePath}} -> {{.TargetURL}}
    location {{.SourcePath}} {
        return {{.Code}} {{.TargetURL}}{{if .PreservePath}}$uri{{end}}{{if .PreserveQuery}}$is_args$args{{end}};
    }
{{end}}{{end}}
{{range .AuthZones}}{{if .IsEnabled}}
    # Auth Zone: {{.PathPrefix}}
    location {{.PathPrefix}} {
        auth_basic "{{.Realm}}";
        auth_basic_user_file {{$.AuthPath}}/zone_{{.ID}}.htpasswd;
        try_files $uri $uri/ =404;
    }
{{end}}{{end}}
    location / {
        try_files $uri $uri/ =404;
    }

    # Deny access to hidden files
    location ~ /\. {
        deny all;
    }
}
{{if .HasSSL}}
server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;

    server_name {{.ServerNames}};

    ssl_certificate /etc/letsencrypt/live/{{.Site.Name}}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/{{.Site.Name}}/privkey.pem;
    ssl_session_timeout 1d;
    ssl_session_cache shared:SSL:50m;
    ssl_session_tickets off;

    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;

    # HSTS
    add_header Strict-Transport-Security "max-age=63072000" always;

    root {{.PublicPath}};
    index index.html index.htm;

    access_log /var/log/nginx/{{.LogName}}_access.log;
    error_log /var/log/nginx/{{.LogName}}_error.log;

    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
{{range .Redirects}}{{if .IsEnabled}}
    # Redirect: {{.SourcePath}} -> {{.TargetURL}}
    location {{.SourcePath}} {
        return {{.Code}} {{.TargetURL}}{{if .PreservePath}}$uri{{end}}{{if .PreserveQuery}}$is_args$args{{end}};
    }
{{end}}{{end}}
{{range .AuthZones}}{{if .IsEnabled}}
    # Auth Zone: {{.PathPrefix}}
    location {{.PathPrefix}} {
        auth_basic "{{.Realm}}";
        auth_basic_user_file {{$.AuthPath}}/zone_{{.ID}}.htpasswd;
        try_files $uri $uri/ =404;
    }
{{end}}{{end}}
    location / {
        try_files $uri $uri/ =404;
    }

    location ~ /\. {
        deny all;
    }
}
{{end}}
`

type nginxTemplateData struct {
	Site        *models.Site
	ServerNames string
	Redirects   []*models.Redirect
	AuthZones   []*models.AuthZone
	PublicPath  string
	LogName     string
	AuthPath    string
	HasSSL      bool
}

func (s *NginxService) GenerateConfig(siteID int64) (string, error) {
	site, err := s.siteRepo.GetByID(siteID)
	if err != nil {
		return "", fmt.Errorf("get site: %w", err)
	}

	// Load aliases
	aliases, err := s.domainRepo.ListBySite(siteID)
	if err != nil {
		return "", fmt.Errorf("get aliases: %w", err)
	}
	site.Aliases = make([]models.Domain, len(aliases))
	for i, d := range aliases {
		site.Aliases[i] = *d
	}

	// Get all hostnames (primary + www + aliases)
	hostnames := site.GetAllHostnames()
	serverNames := strings.Join(hostnames, " ")

	// Get redirects if repo is set
	var redirects []*models.Redirect
	if s.redirectRepo != nil {
		redirects, err = s.redirectRepo.ListBySite(siteID)
		if err != nil {
			return "", fmt.Errorf("get redirects: %w", err)
		}
	}

	// Get auth zones if repo is set
	var authZones []*models.AuthZone
	if s.authZoneRepo != nil {
		authZones, err = s.authZoneRepo.ListBySite(siteID)
		if err != nil {
			return "", fmt.Errorf("get auth zones: %w", err)
		}
	}

	sitePath := filepath.Join(s.config.Sites.Path, fmt.Sprintf("%d", siteID))

	// Convert domain to log-safe name: example.com -> example_com
	logName := strings.ReplaceAll(site.Name, ".", "_")

	data := nginxTemplateData{
		Site:        site,
		ServerNames: serverNames,
		Redirects:   redirects,
		AuthZones:   authZones,
		PublicPath:  filepath.Join(sitePath, "public"),
		LogName:     logName,
		AuthPath:    filepath.Join(sitePath, "auth"),
		HasSSL:      site.SSLEnabled,
	}

	tmpl, err := template.New("nginx").Parse(nginxSiteTemplate)
	if err != nil {
		return "", fmt.Errorf("parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("execute template: %w", err)
	}

	return buf.String(), nil
}

func (s *NginxService) WriteConfig(siteID int64) error {
	config, err := s.GenerateConfig(siteID)
	if err != nil {
		return err
	}

	configPath := s.getConfigPath(siteID)

	// Ensure directory exists
	if err := os.MkdirAll(filepath.Dir(configPath), 0755); err != nil {
		return fmt.Errorf("create config directory: %w", err)
	}

	// Write config file
	if err := os.WriteFile(configPath, []byte(config), 0644); err != nil {
		return fmt.Errorf("write config file: %w", err)
	}

	return nil
}

func (s *NginxService) RemoveConfig(siteID int64) error {
	configPath := s.getConfigPath(siteID)
	if err := os.Remove(configPath); err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("remove config file: %w", err)
	}
	return nil
}

func (s *NginxService) TestConfig() error {
	cmd := exec.Command("sudo", "nginx", "-t")
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("nginx test failed: %s", string(output))
	}
	return nil
}

func (s *NginxService) Reload() error {
	// Test config first
	if err := s.TestConfig(); err != nil {
		return err
	}

	cmd := exec.Command("sudo", "nginx", "-s", "reload")
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("nginx reload failed: %s", string(output))
	}
	return nil
}

func (s *NginxService) ApplyConfig(siteID int64) error {
	// Backup existing config
	configPath := s.getConfigPath(siteID)
	backupPath := configPath + ".backup"

	// Read existing config for backup
	existingConfig, _ := os.ReadFile(configPath)

	// Write new config
	if err := s.WriteConfig(siteID); err != nil {
		return err
	}

	// Test nginx config
	if err := s.TestConfig(); err != nil {
		// Rollback on failure
		if len(existingConfig) > 0 {
			os.WriteFile(configPath, existingConfig, 0644)
		} else {
			os.Remove(configPath)
		}
		return fmt.Errorf("config test failed, rolled back: %w", err)
	}

	// Remove backup if exists
	os.Remove(backupPath)

	// Reload nginx
	return s.Reload()
}

func (s *NginxService) getConfigPath(siteID int64) string {
	return filepath.Join(s.config.Nginx.ConfigPath, fmt.Sprintf("panel-%d.conf", siteID))
}
